---
title: "Tutorial: How to use fhpredict"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Install the package

Install the package fhpredict from GitHub, using the package remotes. Install
from the "dev" branch to get the latest version:

```{r eval = FALSE}
# install.packages(remotes)

remotes::install_github("kwb-r/fhpredict@dev", build_vignettes = TRUE)
```

## Users

In the data model of the app everything is assigned to a user identified by
a unique identifier, the user id. To get an overview on available users and 
their associated ids, run:

```{r}
# Get overview on available users in a data frame
users <- fhpredict::api_get_users()

# Print the data frame
users
```

## Bathing Spots

### Overview on available bathing spots

Use the function `api_get_bathingspot()` to get an overview on the bathing spots
that are stored in the postgres database. You need to specify the user to whom
the bathing spots are associated. See above for how to get a list of available
user ids.

```{r}
# Get overview on the first "limit" bathingspots associated to user with id 3
bathing_spots <- fhpredict::api_get_bathingspot(user_id = 3)

# Number of bathing spots returned
nrow(bathing_spots)
```

By default, only the first `r nrow(bathing_spots)` bathing spots are considered
in the returned data frame. Set the argument `limit` to a high number so that
you get a list of all available bathing spots:

```{r}
# Get overview on all bathing spots associated to user with id 3
all_bathing_spots <- fhpredict::api_get_bathingspot(user_id = 3, limit = 10000)

# Number of bathing spots returned
nrow(all_bathing_spots)
```

### Fetching data related to one bathing spot

Use the overview as retrieved above to lookup the bathing spot id that you are 
interested in. Then, call `api_get_bathingspot()` again, this time by setting 
the argument `spot_id` accordingly:

```{r}
# Lookup bathing spots of interest by name
all_bathing_spots[grep("AHLBECK", all_bathing_spots$name), c("id", "name")]

# Lookup the bathing spot id and store it in a variable spot_id
spot_id <- 1170

# Load the data available for the corresponding bathing spot id
spot <- fhpredict::api_get_bathingspot(user_id = 3, spot_id = spot_id)
```

It is also possible to get a bathing spot without specifying a user id:

```{r}
# It is also possible to get a bathing spot without specifying a user id
spot_no_user <- fhpredict::api_get_bathingspot(spot_id = spot_id)

# Is this the same as what we get when a user is specified?
identical(spot, spot_no_user)
```

### Accessing the properties of a bathing spot

The variable `spot` now contains a list of properties of the selected bathing
spot. As the list contains a lot of `NULL` elements, we remove these elements 
before looking at the overall structure of the list:

```{r}
# Look at the overall structure of the list omitting any NULL element
str(kwb.utils::excludeNULL(spot), 1)
```

Use the `$` operator to access the different properties of the bathing spot:

```{r}
spot$id
spot$nameLong
```

#### Polygon defining the "catchment area"

We are especially interested in the coordinates of the polygon that defines the
area over which to average the rain data that is assumed to influence the
water quality of the bathing spot. This information is stored in the list 
element `area`. It can be transformed into a GeoJSON string using the function
`toJSON()` frmo the jsonlite package. There is also a list element 
`area_coordinates` that contains the same coordinates in the form of a two
column data frame.

```{r}
# Polygon coordinates as a GeoJSON string
jsonlite::toJSON(spot$area)

# Polygon coordinates as a data frame
head(spot$area_coordinates)
```

#### Water quality measurements

The `spot` object contains the results of water quality measurements in its list
element `measurements`. Use the (non-exported) function `flatten_recursive_list`
to convert the corresponding recursive list into a data frame.

```{r}
# Provide the measurements related to the bathing spot
measurements <- fhpredict:::flatten_recursive_list(spot$measurements)

# Have a look at the first measurements (after removing empty columns)
head(kwb.utils::removeEmptyColumns(measurements))
```

## Models

### Overview on available models

Use the function `api_get_model()` to get an overview on the models that are
stored in the postgres database. You need to pass the user id (here: 3) and
the id of the bathing spot (here: 18) to the function.

```{r}
# Read all models that are stored for one bathing spot of one user
model_info <- fhpredict::api_get_model(user_id = 3, spot_id = 18)
```

The function returns a data frame with one row per available model:

```{r}
# Show meta information on the models
model_info
```

Use this overview on available models to lookup the id of the model that you 
actually want to fetch from the database. 

### Fetching a model

Use the model id to fetch a specific model from the database:

```{r}
# Load model with id 27 from the database
model <- fhpredict::api_get_model(user_id = 3, spot_id = 18, model_id = 27)
```

```{r}
# Show the (rstan) model
print(model)
```

### Saving a model

For testing purposes we store a simple, small object instead of a STAN model.
We use the `cars` dataset that is shipped with "base R". Use the function 
`api_add_model()` to add the "model" to the database:

```{r}
# Look at the head of the cars dataset
head(cars)

# Add the cars dataset to the database
model_id <- fhpredict:::api_add_model(
  user_id = 3, spot_id = 18, model = cars, comment = "Cars in R"
)
```

The function returns the id of the model that was given by the database. We
stored the id in the variable `model_id`. To check if the model arrived in the
database we read it back, again using `api_get_model()`

```{r}
# Read the "model" back
my_cars <- fhpredict::api_get_model(3, 18, model_id)
```

We convince ourselves that what we get is identical to what we stored:

```{r}
# Nothing should have changed!
identical(cars, my_cars)
```

### Deleting a model

Use the function `api_delete_model()` to remove a model from the database. 
Let's delete the model that we just added. Its id is given in the variable
`model_id`.

```{r}
# Delete the model with the id given in "model_id"
fhpredict::api_delete_model(3, 18, model_id)
```

## Purification Plants

Use the following script to check if there are any purification plants defined.
As there are many bathing spots, the script takes quite a long time and is not
run here so that you do not see any outputs.

```{r eval = FALSE}
# Get meta information on all bathing spots
bathing_spots <- fhpredict::api_get_bathingspot(user_id = 3, limit = 10000)

# Number of bathing spots
nrow(bathing_spots)

# Access the "purificationPlants" endpoint for each bathing spot
purification_plants <- lapply(bathing_spots$id, function(spot_id) {
  
  message("spot id = ", spot_id)
  
  result <- fhpredict::postgres_get(path = sprintf(
    "%s/purificationPlants", 
    fhpredict:::path_bathingspot(user_id = 3, spot_id = spot_id)
  ))
  
  fhpredict:::stop_on_request_failure(result)
  
  result$data
})

# How many bathing spots have purification plants?
sum(lengths(purification_plants) > 0)
```

